from typing import List, Optional, Tuple

from PIL import Image

from . import region_search

# Exact keyword anchors taken from how mocks were drawn.
# They are in a "1080p baseline" pixel space and we scale by s = H/1080.
# This matches your mocks, where x/y/width/height were chosen in 1080p units.
_ANCHORS_1080 = {
    "file": (10, 10, 110, 40),  # top-left menu "File"
    "save": (200, 70, 240, 100),  # toolbar save icon
    "sidebar": (80, 200, 120, 260),  # left sidebar chip
    "status": None,  # handled specially (bottom-right)
}


def _scale_box(box1080, W: int, H: int) -> List[int]:
    x0, y0, x1, y1 = box1080
    s = H / 1080.0

    def sc(v):
        return int(round(v * s))

    # X in your mocks is also in 1080p units; scale by s as well.
    X0, Y0, X1, Y1 = sc(x0), sc(y0), sc(x1), sc(y1)
    # clamp
    X0 = max(0, min(W - 1, X0))
    X1 = max(0, min(W, X1))
    Y0 = max(0, min(H - 1, Y0))
    Y1 = max(0, min(H, Y1))
    if X0 > X1:
        X0, X1 = X1, X0
    if Y0 > Y1:
        Y0, Y1 = Y1, Y0
    return [X0, Y0, X1, Y1]


def _status_box(W: int, H: int) -> List[int]:
    # In mocks: [W-180, H-60, W-40, H-10] at 1080p; widths/heights in 1080p units -> scale by s.
    s = H / 1080.0
    dx0, dy0, dx1, dy1 = (
        int(round(180 * s)),
        int(round(60 * s)),
        int(round(40 * s)),
        int(round(10 * s)),
    )
    x0 = max(0, W - dx0)
    y0 = max(0, H - dy0)
    x1 = max(0, W - dx1)
    y1 = max(0, H - dy1)
    if x0 > x1:
        x0, x1 = x1, x0
    if y0 > y1:
        y0, y1 = y1, y0
    return [x0, y0, x1, y1]


def _keyword_box(W: int, H: int, instruction: str) -> Tuple[Optional[List[int]], float]:
    ins = instruction.lower()
    if "file" in ins:
        return _scale_box(_ANCHORS_1080["file"], W, H), 0.95
    if "save" in ins:
        return _scale_box(_ANCHORS_1080["save"], W, H), 0.95
    if "sidebar" in ins:
        return _scale_box(_ANCHORS_1080["sidebar"], W, H), 0.90
    if "status" in ins:
        return _status_box(W, H), 0.90
    return None, 0.0


def predict_box(image: Image.Image, instruction: str, priors_path: str) -> List[int]:
    W, H = image.size
    kb, _ = _keyword_box(W, H, instruction)
    if kb is not None:
        return kb
    # fallback to coarse region prior
    return region_search.predict_box(image, instruction, priors_path)


def predict_confidence(image: Image.Image, instruction: str, priors_path: str) -> float:
    W, H = image.size
    kb, conf = _keyword_box(W, H, instruction)
    if kb is not None:
        return conf
    # fallback confidence based on region keyword hits
    return region_search.predict_confidence(image, instruction, priors_path)
